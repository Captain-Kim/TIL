> 이 문서는 「비전공자를 위한 이해할 수 있는 IT지식(최원영 저)」의 내용을 학습하여 메모한 내용입니다.

## 프로그래밍 (Programing)

### 인간이 컴퓨터와 소통하는 방법 (컴파일러)

- 자연어(Natural Language) : 인간이 사용하는 언어
- 기계어(Machine Code) : 컴퓨터가 사용 하는 언어. 2진법으로 구성되어 있음. (0과 1)
- 프로그래밍 언어(Programing Language) : 자연어를 기계어로 바꾸기 전 사용하는 언어 (C언어, 자바, 파이썬 등)
- 컴파일러(Compiler) : 프로그래밍 언어를 기계어로 바꾸어 주는 번역 프로그램

### 프로그래밍(Programing)과 코딩(Coding)의 차이

- 코딩(Coding) : 프로그래밍 언어를 통해 코드를 작성하는 행위 자체
- 프로그래밍(Programing) : 코드의 재사용, 알고리즘 사용 등 프로그램이 작동되는 효율까지 생각하여 프로그램을 제작하는 행위

일반적으로 현업에서는 같은 의미로 사용하지만 프로그래밍이 코딩의 상위 개념.

### 통합 개발 환경 (IDE : Integrated Development Enviroment)

개발을 하기 위한 모든 것을 제공하는 환경을 말함.  
대표적으로 VSCode, Xcode, PyCharm 등이 있다.

(참고 : VSCode는 C언어에 대한 컴파일을 지원하지 않기 때문에 IDE가 아님. 다만 확장기능을 C언어를 컴파일 할 수는 있음.)

### 프로그래밍 언어가 다양한 이유

인간이 사용하는 자연어를 기계어로 바꾸어 주는 프로그래밍 언어와 이를 기계어로 바꾸어 주는 컴파일러가 여러 개발자들에 의해 개발된다.  

사람이 만든 것이다 보니 여러 이용자들이 이용해보고 각 프로그래밍 언어에 어떤 장단점이 있는지 토론하며 많은 발전이 이루어진다.  

예를 들어 C언어가 등장하고 이것이 발전하여 Object-C, C++, Python 등의 언어가 등장하게 되었다.

#### 저수준과 고수준 프로그래밍 언어

- 고수준 (High-level) : 인간 친화적
- 저수준 (Low-level) : 컴퓨터 친화적

|언어 수준|학습 난이도|유지보수|작동속도|
|:-:|:-:|:-:|:-:|
|고수준|쉬움|쉬움|느림|
|저수준|어려움|어려움|빠름|

고수준 언어는 저수준 언어에 비해 인간 친화적이기 때문에 배우기 쉬운 장점은 있지만 인간 친화적인 프로그래밍 언어의 특성 상 컴퓨터 친화적인 저수준 언어보다 이를 해석하는데 몇 단계를 더 거치기 때문에 작동 속도가 저수준에 비해 느리다.  

현대에서는 대부분 모바일 기기나 PC의 사양이 좋아졌기 때문에 고수준 프로그래밍 언어로 만든 프로그램을 사용해도 크게 문제가 없다. 실제로 대부분은 고수준 언어에서 제작된다.  

하지만 IPTV, 복합기, 스캐너, 라디오, 빔프로젝터, 프린터, 스마트 가전 같은 기기는 PC와 같은 사용성을 기대하고 만드는 것이 아니기 때문에 원가 절감을 위해 저수준의 언어로 제작된다.

- 고수준 언어 종류 : Python, Java, JavaScript, C#, Ruby 등
- 저수준 언어 종류 : C, C++, 어셈블리어 등

## 컴퓨터의 구성 요소

### 하드웨어 (Hardware)

#### CPU

사람의 머리에 해당한다.  
데이터를 저장하지는 않는다.

#### 메모리

CPU가 데이터를 처리할 때 보조기억장치에서 데이터를 불러오는데, 이 때 보조기억장치에 저장된 데이터가 너무 많기 때문에 처리 속도가 느려진다.  
그래서 지금 작업 중인 것들은 메모리에 임시로 저장해놓고 여기에서 불러와 처리한다.

#### 보조기억장치

HDD, SSD 등이 이에 해당한다.  
컴퓨터의 창고이다. 데이터를 저장한다.

그리고 위 부품들은 모두 메인보드에 장착되고 서로 호환이 되어야 한다.

### 소프트웨어 (Software)

원래대로라면 보조기억장치에 데이터를 저장하고 지금 사용할 데이터를 메모리에 올리고 CPU로 계산하는 행위를 모두 사용자가 명령해야 할 것이다. 그러나 이 과정이 복잡하기 때문에 운영체제(OS: Operating System)이라는 것이 등장했다.  

운영체제는 사용자가 컴퓨터를 쉽게 다룰 수 있도록 인터페이스를 구성해준다. 따라서 사용자가 직접 하드웨어에 접근하여 관리할 필요없이 운영체제 내에서 시각적으로 컨트롤 가능해졌다.

대표적인 운영체재로는 PC에서는 Microsoft의 Windows, Apple의 MacOS와 iOS(모바일용), Google의 Android가 있다. 이 운영체제들이 시장을 독점하다시피 하고 있고, 이 운영체제들의 정책이 바뀌면 대부분의 산업과 일상에서 큰 영향을 받게 된다.

#### 프로그래밍 언어가 다양해진 이유

운영체제를 만들고 관리하는 회사의 정책의 영향이 크다. 예를들어 Apple의 운영체재에서 작동하는 프로그램을 만들려면 Objective-C나 Swift를, Android에서는 Kotlin이라는 언어를 사용하도록 하고 있다.

#### 다양한 운영체제에 대응하는 방법

Java에서 첫 시도가 이루어졌다. 위 운영체제 회사들이 지금과 같이 독점적인 위치를 차지하기 전까지는 운영체제가 더 다양했기 때문에 언어도 다양했고 개발자들이나 이용자들도 품이 더 많이 갔다.  
이런 문제를 해결하기 위해 Java에서는 JVM(Java Virtual Machine)이라는 소프트웨어를 개발해 어떤 운영체재는 JVM만 설치하면 Java로 개발한 프로그램을 실행할 수 있도록 했다.  

우리는 우리가 JVM을 따로 설치한 적이 없더라도 우리나라 정부 사이트를 이용하거나 Java로 만든 소프트웨어를 사용할 때 JVM을 항상 최신 버전으로 설치하고 업데이트 하고 있다.  

훗날 Python도 이런 방식을 채택하였고, Windows, MacOS 어디서든 Python으로 제작한 프로그램을 사용할 수 있게 됐다.  

그러나 단점이 있다. 해당 운영체제에 최적화된 네이티브 언어로 제작된 프로그램이 아니다 보니 작동 속도가 느리다. 그리고 예전처럼 운영체제가 많던 시절이 아니라 일반사용자들의 경우 PC는 Windows 아니면 MacOS, 모바일은 Android 아니면 iOS가 대부분이기에 그냥 네이티브앱으로 두 명의 개발자가 각각 개발하면 끝이기에 JVM의 단점까지 감수하고 있지는 않는 추세이다.  

또한 Google과 Apple은 자사의 네이티브 프로그래밍 언어가 있는데 굳이 JVM을 허용해줄 이유가 없다. 따라서 이쪽 분야에 대한 지원이 약해 PC에 비해 모바일 시장에서는 JVM의 발전이 더디다.

## 네트워크 (Network)

### LAN (Local Area Network)

컴퓨터가 연결된 작은 지역.  

예를들어 사무실의 한 공간, 학교 컴퓨터실, 아파트 등.

### MAN (Metropolitan Area Network)

여러 LAN이 모여 이룬 하나의 도시.  

### WAN (Wide Area Network)

여러 MAN이 모여 만든 나라, 나라와 나라가 모여 세계가 연결된 네트워크.

### 일상에서 네트워크 동작 원리

사용자 앱스토어에서 카카오톡 앱 다운 -> 가까운 기지국으로 카카오톡 설치파일을 요청하는 신호 전송(WAN) -> 애플 서버로 신호 전달 -> 애플에서 사용자 스마트폰으로 설치파일 전송

### IP 주소

우리가 네트워크를 사용하는 기기는 고유의 주소인 IP 주소를 할당 받는다.

IP주소는 각각 0에서 255까지 숫자로 구성할 수 있고 보통 마침표로 구분하여 4자리로 구분한다. (214.123.142.12)

그런데 네트워크를 사용하는 기기가 늘어날수록 이 주소의 한계가 오기 때문에 최근에는 6자리까지 사용하는 IPv6 방식을 함께 사용하고 있다.

### 클라이언트(Client)와 서버(Server)

클라이언트는 데이터를 달라고 하는 이용자의 컴퓨터, 서버는 그것을 전달해주는 컴퓨터를 이야기한다.  

클라이언트는 자신의 컴퓨터나 모바일 기기를 직접 눈으로 보고 만질 수 있지만 서버는 서비스 제공자가 관리하고 있기에 눈으로 보고 만질 수 없다. 따라서 클라이언트가 이용하는 영역을 프론트엔드(Front-end), 서버를 백엔드(Back-end)라고 한다.

### 리눅스(Linux)와 우분투(Ubuntu)

**리눅스**는 Windows, MacOS와 같은 운영체제(OS) 중 하나다.  
그런데 우리는 실제 환경에서는 Windows나 MacOS를 사용하지만 리눅스를 사용할 일은 잘 없다.  
리눅스는 보통 서버컴퓨터를 운영할 때 많이 사용한다. 서버 컴퓨터는 수많은 이용자의 요청을 처리해야 하고 24시간 동안 켜져 있어야 한다.  

서버 컴퓨터를 가동할 때 Windows나 MacOS를 사용하지 않고 Linux를 사용하는 이유는 간단하다. 리눅스의 개발자 리누스 토르발스가 리눅스를 완전한 무료로 개방했기 때문이다. 이 때문에 수백, 수천대의 컴퓨터가 필요한 서버의 경우 리눅스를 많이 사용했고, 많이 사용하는 만큼 리눅스로 서버를 가동하는데 여러 기술들이 발전해왔다. 이 때문에 해커들의 공격에서도 더 많은 노하우가 집약되었고 오픈소스임에도 보안성까지 우수해지게 되었다.  

이는 오픈소스의 장점인데 Windows는 오픈소스가 아니라 상업적인 OS이기 때문에 Windows의 소스코드를 일반 개발자들이 확인하고 이용하지 않는다. 그러나 리눅스는 오픈소스이기 때문에 수많은 개발자들이 이용하면서 수많은 버그를 스스로 고쳐가며 발전시켜왔다.  

또한 리눅스는 다른 OS와는 다르게 패치, 업데이트가 이루어지고 나서 재부팅하지 않아도 되어 24시간 동안 켜두어야 하는 서버 컴퓨터에는 더없이 좋다.

(참고 : 리누스 토르발스는 리눅스와 더불어 버전관리시스템인 Git의 창시자이다.)

**우분투**는 리눅스의 버전 중 가장 유명한 버전의 이름이다. Windows에 XP, Vista, 10, 11과 같이 버전명이 붙은 것과 같다.  

우분투와 더불어 유명한 리눅스의 버전 중 하나는 **레드햇(Red hat)**인데 리눅스 사용을 편리하게 개량하여 유료로 판매하는 버전이다. 리눅스는 오픈소스인데 굳이 유료로 구매할 필요가 있나 싶지만 금융권 같이 절대로 서버에서 에러가 발생하면 안 되는 분야에서는 오픈소스를 사용하다가 문제가 발생하면 오롯이 본인 책임이기에 서비스의 품질을 보장해줄 수 있는 레드햇을 많이 이용한다.  

구글의 Android 또한 리눅스를 개량해서 만든 OS이다.  

리눅스와 우리가 사용하는 Windows, MacOS와의 큰 차이점은 그래픽UI 요소 여부이다. 대중들이 사용하기 쉽도록 바탕화면, 폴더, 파일, 휴지통 등이 있는 개념을 OS에 스티브 잡스가 적용시키며 PC는 이 두 개의 OS가 양분하게 되었고 리눅스는 터미널을 통해 명령어로만 작동한다. 따라서 진입장벽은 훨씬 높다.

### 호스팅(Hosting)

개인이 서버를 돌리기에는 비용 문제, 관리 문제 등으로 어려움이 크다. 이를 대신 해주는 업체에서 제공하는 서비스가 서버 호스팅(Server Hosting)  

- 국내 : 카페24, 가비아
- 해외 : AWS(Amazon Web Servives) 등

## API(Application Programming Interface)

애플리케이션 프로그램 인터페이스.  

클라이언트가 서버에 요청을 보낼 때 수많은 요청들을 구분해 줄 체계가 필요하다. 이것이 API이다.  
클라이언트가 회원정보를 요청하면 회원정보를 담당하는 서버로 요청을 보내 응답을 보내주고, 이미지를 요청하면 이미지를 담당하는 서버로 요청을 보내 응답을 보내준다.  
즉 이를 API로 구분하여 서버주소/A, 서버주소/B 등으로 각 요청을 응답할 서버로 분류해 수많은 요청에 효율적으로 응답한다.  

클라이언트와 서버가 요청과 응답을 주고 받을 때는 데이터가 함께 움직인다. 예를 들어 클라이언트가 '타임라인에 사진을 올리는 요청'을 했을 때는 클라이언트가 사진도 함께 보내주어야 한다.

### CRUD

클라이언트가 서버에 하는 요청은 크게 네 가지 틀을 갖는다. 이를 **CRUD**라고 한다.  

|요청|의미|Method|
|:-:|:-:|:-:|
|Creat|생성|POST|
|Read|읽기|GET|
|Update|갱신|PUT(전체),PATCH(일부)|
|Delete|삭제|DELETE|

클라이언트의 요청은 대부분 이 틀에서 벗어나지 않기 때문에 개발자는 개발을 할 때 CRUD의 관점에서 기능을 구현해야 한다. 데이터 생성은 되는데 수정이 안 되거나 하는 경우 데이터를 올바르게 처리할 수 없다.  

API는 이러한 요청별로 별도의 주소를 갖고 각 요청을 API 체계에 따라 분류하고 효율적으로 응답한다.  

그런데 이렇게 API를 세부적으로 나누다 보면 끝도 없이 주소가 늘어나고 효율적으로 관리하기 오히려 어려워지고 복잡해지는 문제가 생긴다. 그러다 API 간 충돌이 발생하기도 하고 여러 버그가 발생한다.  

### RESTful API

이를 효율적으로 관리하고자 하는 움직임이 생겼고 좀 더 체계적인 API인 **RESTful API(Representational State Transfer)** 체계가 등장하게 된다.

RESTful API는 위 표에서 CRUD로 나타내는 각 요청들이 갖는 의미를 Method 형태로 체계를 만들었다.  

### HTTP 상태코드

여러가지 서비스를 복잡하게 제공하는 서비스에서는 클라이언트가 정보 열람의 권한이 있는지 확인한 후 있다면 정보를 보내주는 방식으로 보안을 준수한다. 그런데 회원가입부서, 이메일부서 등 담당 부서가 많게 되면 고객이 ID나 P/W를 틀린 경우 다시 확인하라는 에러 메시지를 출력해야 하는데 부서별로 멘트가 통일되어 있지 않으면 이 또한 비효율을 낳게 되는 문제가 있었다.  

클라이언트의 요청에 따라 응답하는 방법을 통일한 것이 HTTP 상태코드이다.

- 100 Continuew : 클라이언트가 계속해서 요청하거나 이미 요청을 완료한 경우에는 무시해도 되는 것
- 101 Switching Protocol : 서버에서 프로토콜을 변경할 것임을 알림
- 200 OK : 요청 응답 성공
- 403 Forbidden : 클라이언트가 컨텐츠에 접근할 권한이 없음.
- 404 Not Found : 서버는 요청받은 리소스를 찾을 수 없음.
- 500 Internal Server Error : 서버가 처리 방법을 모르는 상황이 발생하였고 서버는 아직 처리 방법을 알지 못함.

위의 예시는 일부이며 자세한 사항은 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)에 잘 정리되어 있다.

### SDK (Software Development Kit)

소프트 웨어를 개발하는 도구.  

API는 클라이언트와 서버 간의 데이터 처리 방법을 정리한 체계이다. 하지만 개발자들 간에도 API를 통한 소통이 자주 발생한다.  

예를 들어 정부사이트에 많이 있는 간편인증은 카카오톡, 네이버 등으로 간편인증하는 민간인증 시스템들이 있다. 원래대로라면 정부의 모든 사이트가 이 기능을 개발해서 사이트에 적용시켜야 하지만 카카오, 네이버라는 SDK에서 이미 솔루션을 제작해놓았기에 이를 이용하고자 하는 개발자는 SDK에서 제공하는 API를 사용하여 자신의 사이트나 프로그램에서 다른 소프트웨어의 기능들을 활용할 수 있게 된다.

### JSON (JavaScript Object Notation)

JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기준의 표준 포맷.

사전적 정의는 어렵지만 클라이언트와 서버가 요청을 주고 받을 때 데이터가 함께 움직인다고 위에서 언급했다.  

예를 들어서 클라이언트가 서버에게 "내 피드에 있는 사진 보여줘"라고 명령을 보내면 "일단 로그인하라"고 서버가 응답할 수 있다. 이 때 클라이언트는 ID와 P/W를 입력하여 전송해야 한다. 이 때는 텍스트 데이터가 움직일 것이고, 권한이 확인되면 서버에서는 사진 데이터를 보내주게 된다.  

그런데 이 데이터 형식이 이용하는 사람마다 모두 다를 수 있다. 예를 들어 누군가는 "제 아이디는 123 비밀번호는 456입니다."라고 보낼 수도 있고 누군가는 "ID : 123, P/W : 456"이라고 보낼 수도 있다.  

따라서 이런 데이터 형식에 대해 통일하고자 하는 움직임이 있었고, 과거에는 **XML** 형식이 많이 쓰였으나, 지금은 **JSON** 형식이 많이 사용된다.

JSON은 기본적으로 배열과 객체의 형태로 관리된다.  

```
"users": [
    {
        "id": jangwonyoung,
        "name": "장원영",
        "email": "wy123@naver.com",
        "password": "1234"
    }
]
```


참고 : API 문서화를 도와주는 서비스 [GitBook](https://www.gitbook.com/)

## 응용 프로그램 (Application)

의미 : 설치해서 사용하는 모든 프로그램을 일컫는다.  

줄여서 어플, 앱이라고 부른다.  

### 버전 관리

보통 마침표를 구분자로 하여 세 자리로 표현한다. (0. 0. 0)

가장 마지막은 작은 변화를 의미한다.  
중간 자리는 하위 버전과 호환이 가능하지만 큰 변화를 의미한다.  
가장 왼쪽은 하위 버전과 호환이 가능하지 않은 큰 변화를 의미한다.  

대부분의 서비스에서 이용자에게 버전 업데이트를 강제한다. 모두가 같은 서비스를 이용할 수 있게 하기 위함이다. 따라서 가격이 인상되었을 때 낮은 버전의 사람에게는 10,000원으로 보이고, 버전 업데이트를 한 사람에게는 인상된 가격인 20,000원으로 보이는 문제가 없도록 앱 자체에는 변동 가능한 정보를 넣지 않고 서버에서 API로 불러온다. 이렇게 하면 가격이 수시로 변동되더라도 API만 수정하면 모두에게 같은 정책으로 변경시킬 수 있다.  

### 구글과 애플의 앱 생태계  

윈도우도 마찬가지이지만 구글과 애플은 각자의 앱 마켓이 있다. 구글은 플레이스토어, 애플은 앱스토어이다. 이곳에 개발자들이 앱을 등록해서 심사과정을 거쳐 정식적으로 앱을 등록해야 한다.  

구글은 심사과정이 거의 없다시피 하여 반나절 정도 소요되고 애플은 하루에서 그 이상 소요된다.  

장단점이 있는데 구글은 앱 마켓 등록이 빠른 대신 검증되지 않은 앱들도 많이 있다. 애플은 사전검증을 거치기 때문에 상대적으로 오작동을 하거나 버그를 발생시키는 앱이 거의 없다.

## 웹 (Web)

웹은 크게 HTML, CSS, JavaScript로 이루어져 있다.  

### HTML (Hyper Text Markup Language)

유럽 입자 물리 연구소(CERN)에서 개발하여 출발하였다.

당시 사람들이 각자의 방식으로 데이터를 문서화하고 전달하는 비효율적인 모습들이 많이 있어 브라우저만 있다면 모두 일정한 형식으로 같은 문서를 볼 수 있는 HTML을 개발하게 된다.  
HTML이 등장하고 OS가 다르더라도 모두 같은 웹 문서를 볼 수 있게 되었다.  

HTML은 \<img>, \<a>와 같은 태그(Tag)로 이루어져 있는데 얼핏 보면 프로그래밍 언어같지만 HTML은 프로그래밍 언어가 아니라 단지 브라우저가 볼 수 있는 문서를 적는 언어이다. 프로그래밍 언어는 컴퓨터에게 특정한 일을 시킬 수 있는 언어를 이야기 하는 것이다. HTML처럼 문서를 만들어 주는 것이 아니다.

### CSS (Cascading Style Sheets)

HTML이 정보 전달에만 집중하다 보니 문서의 디자인적인 측면에서는 아쉬움이 컸다. HTML문서를 상업적으로도 이용하게 되면서 그래픽 디자인도 추가하고자 하는 니즈가 생겨나 HTML로 정보를 표현한 문서에 디자인을 입힐 수 있는 CSS 코드가 개발되게 된다.  

HTML과 CSS를 통해 웹 문서를 만드는 것을 웹 퍼블리싱(Web Publishing)이라 하고 이를 하는 사람을 웹 퍼블리셔라고 한다. 또는 마크업(Markup)이라고도 한다.

### JavaScript

위와 같이 퍼블리싱 된 웹 문서에 기능을 넣을 수 있는 프로그래밍 언어이다. 예를 들어 쇼핑몰을 만들었다면 장바구니, 구매하기 등을 퍼블리싱으로는 만들 수는 있지만 그것이 기능을 할 수 있게 할 순 없다. 여기서 JavaScript를 이용하면 버튼을 클릭하거나 특정 동작을 하거나 할 때 서버에 데이터를 보낼 수도 있고 데이터를 불러올 수도 있고 동적인 기능을 삽입할 수 있다.

자바스크립트와 자바는 관련이 없다. 자바가 먼저 나온 언어이고 자바스크립트는 최초 LiveScript라는 이름으로 출발했지만 당시 Java가 많은 인기를 얻고 있어 Java 개발자들을 타깃으로 하기 위해 이름을 JavaScript로 하였다는 말이 있다.

### 웹과 앱의 차이

|구분|수정방법|데이터|속도|
|:-:|:-:|:-:|:-:|
|Web|서버에서 수정|서버에 있음|상대적으로 느림|
|App|앱 업데이트|사용자 기기에 있음|상대적으로 빠름|

### 브라우저의 파편화 (Browser fragmentation)

브라우저의 표준화(Browser unity)의 반댓말이다.  
브라우저가 하나로 통일되지 않고 여러개로 나뉘는 현상을 말한다.  
우리가 사용하는 브라우저는 크롬, 사파리, 파이어폭스, 오페라 등 다양하다. 문제는 HTML, CSS, JavaScript는 계속해서 업데이트되며 발전하는데 이 브라우저들과 함께 하지 못하는 경우가 많다. 이런 경우 크롬에서는 잘 작동하는 소스코드가 사파리에서는 보이지 않는 경우가 있기도 하다.  

인터넷 익스플로러와 같이 지원이 없거나 중단 수순을 밟고 있는 브라우저들에서 이런 문제가 두드러진다.  

웹 개발자들이 실무에서 가장 힘들어 하는 부분이고 파편화를 잡는 작업도 손이 많이 간다. 브라우저의 파편화 때문에 [caniuse](caniuse.com)와 같은 사이트도 생겼다. CSS Grid Layout 같은 것들은 다른 브라우저에서는 다 되는데 오페라mini 등에서는 작동하지 않는다고 알려주고 있다.  

브라우저가 워낙 다양하기 때문에 웹 개발자는 파편화를 완벽히 잡을 순 없고 브라우저의 점유율을 보고 선택적으로 판단하게 된다.

### 반응형 웹 (Responsive Web)

브라우저를 사용하는 기기들이 PC 뿐만 아니라 스마트폰, 태블릿, 키오스크, 홈IoT 가전제품 등 다양하게 등장하면서 출력되는 화면과 클릭인지 터치인지 이용 방식 등이 다양해지게 되었다.  

따라서 이용자가 어떤 기기를 이용하느냐에 따라 같은 웹을 다르게 보여주는 기술을 말한다.

네이버나 카카오 같은 회사는 m.naver.com과 같이 PC버전의 네이버와 모바일 버전의 네이버를 따로 개발하였다. 하지만 모든 회사가 이런 식으로 작업하기에는 시간과 비용이 많이 소모되기 때문에 하나의 웹을 만들고 그것을 사용자 기기에 따라 반응형으로 만드는 것이 더 효율적이다.  

일반 웹을 만드는 것보다 더 많은 코드가 필요하고 시간이 소요되기 때문에 bootstrap과 같은 라이브러리를 많이 사용한다.

### 네이티브 앱(Native App)과 하이브리드 앱(Hybrid App)

운영체제에서 권장하는 프로그래밍 언어로 만든 애플리케이션을 네이티브 앱이라 하고, 뼈대는 네이티브 앱으로 만들지만 특정 영역을 브라우저를 실행시켜 HTML, CSS, JavaScript로 만들어진 문서를 앱과 같게 디자인하고 보여주는 것을 하이브리드 앱이라고 한다.  

네이티브 앱을 수정하려면 앱의 코드를 수정하고 앱 마켓의 심사를 거쳐야 하지만 하이브리드 앱은 문서만 바꾸면 된다. 이렇게 보면 하이브리드 앱이 좋아 보이지만 네이티브 앱만큼 빠른 속도를 보장할 수 없고 기기에서 사진을 불러온다든지 사용자가 허락한 권한을 부여할 수 없어 기능에 제약이 따르기도 하기 때문에 목적에 맞게 제작하게 된다.  

예를 들어 브라우저를 통해 불러오는 문서는 서버에서 모든 데이터를 불러오는 것이기에 사용자가 체감하기에 네이티브 앱보다 반응이 느리게 느껴질 수밖에 없어 사용성을 떨어뜨릴 수 있다.  

그러나 업데이트가 잦은 네이티브 앱은 오히려 사용자들에게 불쾌감을 불러 일으킬 수 있기 때문에 이런 영역은 하이브리드로 개발하는 것이 나은 선택지일 수도 있다.

|구분|개발 언어|성능|뷰어|개발 시간|수정 용이성|
|:-:|:-:|:-:|:-:|:-:|:-:|
|네이티브 앱|자바, 코틀린, 오브젝트씨, 스위프트|높음|앱 자체|오래 걸림|오래 걸림|
|하이브리드 앱|HTML, CSS, JS|낮음|브라우저|빠름|수정 용이함|


## 데이터베이스(Database)

쇼핑몰로 예를 들면 회원정보, 아이디, 패스워드, 구매정보 등은 하나하나 데이터(Data)이다. 그리고 이것들이 모인 것이 데이터베이스(Database)이다.  

하나의 서비스를 하는데도 수집하고 관리해야 하는 데이터들은 너무나도 많고, 심지어 서로 유기적으로 연관되어 있다.  

예를 들어 홍길동이라는 회원정보가 단순히 이름에만 국한되는 것이 아니라 이 회원정보를 통해 구매정보 등도 불러와야 하기 때문에 거의 모든 데이터가 유기적으로 연관되어 있다고 봐도 무방하다.

이런 데이터가 수백~수천만 건이 넘어가면 한 사용자의 CRUD 요청에도 서비스는 버벅일 수 있고 효율적이지 못하게 된다. 홍길동이라는 이용자가 이름을 강감찬으로 바꾸었다면 '이름'이라는 데이터만 바꾸는 것이 아니라 이름과 연관되어 있는 모든 데이터를 수정해야 하는 비효율도 낳게 된다.  

이를 보완하고자 **관계형 데이터베이스(SQL : Structured Query Language)**라는 데이터베이스 관리 방법론이 등장하게 되고, 근 30년 간 지배적으로 사람들은 이 방법을 이용하여 데이터베이스를 관리하고 있다.  

예를 들어 우리가 흔히 사용하는 엑셀을 보면 행별로 고객 이름, 일련번호, 아이디, 패스워드 등을 쭉 입력해놓고 필요한 데이터가 있다면 Vlookup 등의 함수를 사용해서 데이터를 불러올 것이다. 이렇게 관리하면 수백만 건의 데이터도 서로 꼬일 일이 없다.  

엑셀에서 Sheet에 해당하는 것을 SQL에서는 Table이라 하고 엑셀 파일 자체를 스키마(Schema) 또는 데이터베이스(Database)라고 한다.

관계형 데이터베이스를 관리해주는 소프트웨어는 MS SQL, Oracle DB, MySQL, MariaDB 등이 대중적이고 이를 데이터 베이스 관리 시스템(RDMBS : Relational Database Management System)이라 한다.

### 클라이언트와 서버

데이터베이스는 클라이언트가 직접 저장하기도 하고 서버 컴퓨터에 저장하기도 한다. 모두에게 같은 화면이 보인다면 그것은 서버에서 API를 통해 클라이언트에게 보여주는 것이고, 네트워크 연결이 필요 없이 작동하는 서비스 중 사람마다 다른 화면이 보인다면 클라이언트에게 데이터베이스가 있는 것이다.  

예를 들어 알람 앱에서 알람을 맞춘 것은 서버와는 상관이 없다.

이것을 구분해야 하는 이유는 데이터베이스가 어디에 있는지 명확히 해야 버그가 발생했을 때도 적절히 대응할 수 있기 때문이다.  

**데이터베이스 위치에 따라 지칭하는 용어**

|클라이언트|서버|
|:-:|:-:|
|로컬, 내부 DB, 네이티브, 클라이언트, 프론트엔드|서버, API, DB, 백엔드|

### 이미지 처리

앱을 이용할 때 작은 이미지는 용량이 매우 작지만 큰 경우 몇 십, 몇 백 메가를 넘어 가는 이미지들도 많이 있다.  

작은 이미지는 서버에서 불러와도 로딩이 오래 걸리진 않지만 용량이 큰 이미지를 서버에서 매번 불러오면 트래픽에 부담이 되기도 하고, 또 고객 입장에서는 로딩에 시간이 걸리다 보니 사용성을 떨어뜨릴 수 있다.  

따라서 떄로는 앱에서 모든 이미지를 서버에서 불러오지 않고 클라이언트의 기기에 앱을 설치하면서 같이 저장하기도 한다. 이 이미지는 기기 내부에서 고유의 주소를 가지고 이 주소를 통해 클라이언트 기기에서 바로 load하면 상당히 빠르게 불러올 수 있기 때문이다.  

하지만 서비스가 변경되어 그 이미지를 교체해야 하는 경우에는 앱 업데이트를 해야만 한다. 앱 업데이트가 잦으면 고객 입장에서 또 사용성을 떨어뜨릴 수 있기 때문에 변경이 잦은 이미지는 서버에 저장하고 API를 통해 클라이언트에게 보내준다. 그리고 이런 이미지는 보여지면 안 되는 사람이 있는 경우에는 관계형 데이터베이스에서 이미지 주소를 직접 관리한다.

## 프레임워크(Framework)와 라이브러리(Library)

### 프레임워크(Framework)

각 프로그래밍 언어는 개발자들이 미리 기능을 구현해놓은 프레임워크가 존재한다. 애플로 예를 들면 Cocoa Framework를 애플이 운영하고 있는데 Objective-C나 Swift로 프로그래밍 할 때 필요한 GUI(Graphical User Interface)를 미리 만들어 두고 개발자들에게 제공한다.  

이를 통해 앱 마켓에서는 개발자들의 실력 편차에 의해 앱의 퀄리티가 들쑥날쑥한 문제를 막을 수 있고 보다 품질 좋은 앱 생태계를 구축할 수 있다. 그리고 개발자는 일일이 버튼을 만드느라 코딩해야 했던 것을 간편하게 개발할 수 있게 되었다.

구글과 애플은 이렇게 자체적인 프레임워크를 운영할 수 있지만 웹은 조금 다르다. 웹은 특정인의 소유물이 아니기 떄문에 개발자들이 직접 프레임워크와 라이브러리를 만들어 개발하고 배포한다. 여기에 대기업들도 참여하기도 한다.  

현재 웹에서 유명한 프레임워크는 Angular.js, Rreact.js(페이스북), Vue.js, Spring(Java), Django(Python) 등이 있다.

### 라이브러리 (Library)

프레임워크와 거의 비슷한 의미이지만 개발의 주도권이 누구에게 있느냐로 구분한다. 프레임워크는 해당 기능을 제공하는 프레임워크에게 주도권이 있고 라이브러리는 개발자에게 개발의 주도권이 있다. 이것의 의미는 프레임워크를 사용하면 그 프로젝트에서는 다른 프레임워크를 사용하기 힘들다는 의미이다. 프레임워크는 다른 프레임워크와 혼용하여 사용할 수 있도록 개발된 것이 아니기에 코드에서 충돌이 날 수 있고, 또 프레임워크가 웹의 전체적인 틀을 구성하기 때문에 메모리를 많이 차지하는데 여러개의 프레임워크를 쓰면 웹 자체가 무거워질 수 있다. 이러한 이유로 프레임워크의 주도권은 프레임워크 제작자에게 있다.  

그러나 라이브러리는 프로젝트 전체를 관장하기 보다는 특정 함수나 클래스를 제공할 목적으로 개발되었기 때문에 여러개를 혼합하여 사용해도 큰 문제가 발생하지는 않는다. (물론 좋진 않다.)  

자바스크립트에서는 대표적으로 jQuery, Lodash, Momonet.js 등이 있다.

## Git : 분산 버전 관리 시스템

개발은 1인 개발을 제외하고 대부분은 여러 개발자가 협업하는 것이 대부분이다.

일반 회사에서도 한 문서를 놓고 여러명이 수정하는 과정을 거친다면 분명 어딘가에서 휴먼 에러가 발생할 확률이 높아진다. 그리고 어떤 파일이 최종본인지 마지막으로 사용한 사람 말고는 알기가 어렵고, 이전 사람이 어느 부분을 수정했는지도 알기 어렵다.

개발은 코드가 수천~수만줄에 달하기도 하기 때문에 이러한 문제가 더 심각하고, 또 일반 문서처럼 자연어로 되어 있는 것이 아니기 때문에 다른 사람이 작업한 내용까지 다 검토하려면 상당히 비효율적이다.

그리고 개발은 보통 서비스와 직결되기 때문에 개발자가 코드를 수정하는 과정에서 오류가 발생하면 회사에 치명적인 타격이 생길 수도 있고, 빠르게 이전 버전으로 돌려야 할 수도 있다.

이것을 해결해주는 것이 Git이다.

개발자들은 모든 개발의 단계에 깃발을 꽂는다. 이를 **Commit**이라 한다. 그리고 왜 거기에 깃발을 꽂았는지, 어떤 수정을 했는지 항상 메모한다. 이를 **Commit Log**라고 한다.

이렇게 Git을 통해 깃발을 꽂으면 1번 깃발이 꽂힌 부분에서 2번 깃발이 꽂힌 부분까지 무엇이 달라졌는지 한 눈에 파악하기가 쉽다. 그리고 이 깃발들로 옮겨 다니면서 추적할 수도 있다. 이를 **Check Out**이라 한다.

개발자들이 여러 파트를 각자 나눠 맡으면서 개발을 할 때 하나의 문서를 동시에 열어서 작업하지 않는다. **Branch**라는 개념을 이용해 나무의 가지처럼 기둥(메인)은 그대로 놔둔 상태에서 별도로 각자 맡은 분야를 개발하고 문제가 없다면 **Merge**(병합)하여 Master Branch로 소스코드가 들어가 본 서비스에서도 수정본을 이용할 수 있게 한다.

그리고 이런 과정을 개인 PC인 로컬에서 하게 되면 팀의 리더가 모든 것을 관리해야 하기 떄문에 비효율적이다. 따라서 모든 팀원이 함께 만드는 프로젝트인 만큼 모두가 볼 수 있게, 그리고 또 안전하게 관리하기 위해 클라우드 서비스를 만들었고 현재는 GitHub와 Bitbucket이 가장 유명하다.

## 개발과 디자인

개발자는 앱만 잘 개발하면 되는 것 같지만 실제로는 그렇지 않다. 어떤 서비스든 그래픽적인 요소가 분명히 사용되기 떄문에 디자인 요소가 잘 보일 수 있도록 개발하는 것이 중요하다.

그리고 디자이너는 개발자가 개발한 의도를 잘 알아야 그에 맞게 디자인을 할 수 있다.  

그런데 모든 작업에서 이런 과정을 거치면 상당히 번거롭기 때문에 재플린, XD, 스케치 같은 서비스가 등장했고 개발자가 개발한 것을 토대로 자동으로 디자인 가이드를 제공해주기도 하고, 디자이너가 의도하는 디자인을 적용시키면 소스코드를 어떻게 변경하라는 수정 제안도 해주는 서비스가 생겼다.

개발자는 그래픽 요소가 어떻게 보일 것인지도 고려해서 개발을 해야 한다. 물론 그렇기 때문에 잘 만들어진 프레임워크나 라이브러리를 이용하면 이런 수고로움을 덜 순 있다.

