## useEffect란?

리액트에서 컴포넌트의 사이드 이펙트를 제어하는 훅.


사이드 이펙트는 직역하면 '부작용'이고, 리액트에서 표현하는 사이드 이펙트는 어떤 기능에서 '의도하지 않은 부수적인 효과', 내지 '파생되는 효과' 정도의 개념이다.

## 사용방법

1. import하기

```jsx
// state import 하기
import { useEffect } from "react";
```

2. 원형 작성하기

```jsx
const [count, setCount] = useState(0);
useEffect(()=>{},[]);
// 두 개의 인자를 받는데 첫번째는 콜백함수, 두번째는 의존성 배열(Dependency Array)
// 해석은 Deps의 값이 변경되면 콜백함수가 실행됨.
```

위와 같이 `useState` 훅과 동시에 사용 가능. 카운트 앱에서 사용되는 count state인데, setCount로 값이 변경될 때마다 useEffect 훅의 콜백함수를 실행시킬 수 있다.

3. 사용하기

```jsx
const [count, setCount] = useState(0);
useEffect(()=>{
    console.log(`카운트가 ${count}으로 변경되었습니다.`);
},[count]);
// 이렇게 작성하면 count state가 변경될 때마다 콘솔에 출력됨.
```

4. Deps에 여러 개 값 추가하기

Deps는 배열이기 때문에 여러 개의 값의 변화를 감지할 수 있다.

```jsx
const [count, setCount] = useState(0);
const [input, setInput] = useState('');

useEffect(()=>{
    console.log(`카운트가 ${count}으로 변경되었습니다. 현재 입력필드의 값은 ${input}입니다.`);
},[count, input]);

return (
    <>
        <input value={input} onChange={(e)=>setInput(e.target.value)}/>
    </>
)
```

## useState 훅을 바로 출력하지 않고 useEffect 훅을 사용해야 하는 이유

```jsx
const [count, setCount] = useState(0);
const [input, setInput] = useState('');

return (
    <>
        <input value={input} onChange={(e)=>
        setInput(e.target.value);
        console.log(count);}/>
    </>
)
```

예를 들어서 위처럼 `useEffect` 훅을 이용하지 않고 count state의 변화를 직접 console에서 찍어볼 수 없는지 의문이 든다.


그런데 실제로 저 코드를 콘솔에 출력해보면 카운트가 증가되는 것이 한 박자 늦게 뜬다. 그러니까 나는 카운트를 1 증가 시켰는데 0이 출력되고, 2가 되어야 하는데 1이 출력된다는 것이다.
그 이유는 `useState`훅은 비동기적으로 실행되기 때문이다. 즉 코드의 흐름대로 작성 순서대로 실행되는 것이 아니라 `1. 화면에 렌더링 되는 부분부터 렌더링(return문 내부)` -> `2. 자바스크립트 함수부터 실행(console.log)` -> `3. 가장 마지막에 useState훅 실행` 순서대로인 것이다. `useState` 훅은 코드 흐름대로  Mount만 되지 실행은 가장 마지막에 한꺼번에 모아서 처리하기 때문에 이미 콘솔에 찍히고 나서 카운트가 증가하는 현상, 즉 한 박자 늦게 나오는 현상이 발생한다.


따라서 같은 시점에서 같이 비동기적으로 실행되는 `useEffect`훅을 사용하면 `useState`의 사이드 이펙트, 즉 상태 변화를 즉각 감지할 수 있다.